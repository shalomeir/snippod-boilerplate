var KssHandlebarsEngine,
	KssTemplateEngine = require('../kss_template_engine.js'),
	marked = require('marked'),
	wrench = require('wrench'),
	glob = require('glob'),
	path = require('path'),
	fs = require('fs');

module.exports = KssHandlebarsEngine = new KssTemplateEngine();

KssHandlebarsEngine.init = function(source, destination, template, helpers) {

	// Create a new destination directory.
	try {
		fs.mkdirSync(destination);
	} catch (e) {}

	// Optionally, copy the contents of the template's "public" folder.
	try {
		wrench.copyDirSyncRecursive(
			template + '/public',
			destination + '/public',
			{
				forceDelete: true,
				excludeHiddenUnix: true
			}
		);
	} catch (e) {}

	// Ensure a "public" folder exists.
	try {
		fs.mkdirSync(destination + '/public');
	} catch (e) {}

  // Store the global Handlebars object.
  this.handlebars = require('handlebars');

	// Load Handlebars helpers.
	if (fs.existsSync(helpers)) {
		// Load custom Handlebars helpers.
		var helperFiles = fs.readdirSync(helpers);

		helperFiles.forEach(function(fileName) {
			if (path.extname(fileName) !== '.js') {
				return;
			}
			var helper = require(helpers + '/' + fileName);
			if (typeof helper.register === 'function') {
				helper.register(this.handlebars);
			}
		});

		// Load the standard Handlebars helpers.
		var helperFile = require(__dirname + '/handlebars_helpers.js');
		helperFile.register(this.handlebars);
	}

	// Compile the Handlebars template.
	this.template = fs.readFileSync(template + '/index.html', 'utf8');
	this.template = this.handlebars.compile(this.template);
};

KssHandlebarsEngine.processStyleguide = function(styleguide) {
	var sections = styleguide.section(),
		sectionCount = sections.length,
		sectionRoots = [],
		rootCount,
		currentRoot,
		childSections = [],
		partials = {},
		partial,
		files = [],
		i;

	console.log(styleguide.data.files.map(function(file) {
		return ' - ' + file;
	}).join('\n'));

	// Throw an error if no KSS sections are found in the source files.
	if (sectionCount === 0) {
		throw 'No KSS documentation discovered in source files.';
	}

	console.log('...Determining section markup:');

	for (i = 0; i < sectionCount; i += 1) {
		// Register all the markup blocks as Handlebars partials.
		if (sections[i].markup()) {
			partial = {
				name: sections[i].reference(),
				reference: sections[i].reference(),
				file: '',
				markup: sections[i].markup(),
				data: {}
			};
			// If the markup is a file path, attempt to load the file.
			if (partial.markup.match(/^[^\n]+\.(html|hbs)$/)) {
				partial.file = partial.markup;
				partial.name = path.basename(partial.file, path.extname(partial.file));
				files = [];
				for (var key in argv.source) {
					if (!files.length) {
						files = glob.sync(argv.source[key] + '/**/' + partial.file);
					}
				}
				// If the markup file is not found, note that in the style guide.
				if (!files.length) {
					partial.markup += ' NOT FOUND!';
				}
				console.log(' - ' + partial.reference + ': ' + partial.markup);
				if (files.length) {
					// Load the partial's markup from file.
					partial.file = files[0];
					partial.markup = fs.readFileSync(partial.file, 'utf8');
					// Load sample data for the partial from the sample .json file.
					if (fs.existsSync(path.dirname(partial.file) + '/' + partial.name + '.json')) {
						try {
							partial.data = require(path.dirname(partial.file) + '/' + partial.name + '.json');
						} catch (e) {
							partial.data = {};
						}
					}
				}
			}
			else {
				console.log(' - ' + partial.reference + ': inline markup');
			}
			// Register the partial using the filename (without extension) or using
			// the style guide reference.
			handlebars.registerPartial(partial.name, partial.markup);
			// Save the name of the partial and its data for retrieval in the markup
			// helper, where we only know the reference.
			partials[partial.reference] = {
				name: partial.name,
				data: partial.data
			};
		}

		// Accumulate all of the sections' first indexes
		// in case they don't have a root element.
		currentRoot = sections[i].reference().split(/(?:\.|\s+\-\s+)/)[0];
		if (sectionRoots.indexOf(currentRoot) === -1) {
			sectionRoots.push(currentRoot);
		}
	}

	console.log('...Generating style guide sections:');

	// Now, group all of the sections by their root
	// reference, and make a page for each.
	rootCount = sectionRoots.length;
	for (i = 0; i < rootCount; i += 1) {
		childSections = styleguide.section(sectionRoots[i]+'.*');

		this.generatePage(styleguide, childSections, sectionRoots[i], sectionRoots, partials);
	}

	// Generate the homepage.
	childSections = [];
	this.generatePage(styleguide, childSections, 'styleguide.homepage', sectionRoots, partials);
};

// Renders the handlebars template for a section and saves it to a file.
KssHandlebarsEngine.generatePage = function(styleguide, sections, root, sectionRoots, partials) {
	var filename = '', files,
		homepageText = false,
		styles = '',
		scripts = '';

	if (root == 'styleguide.homepage') {
		filename = 'index.html';
		console.log(' - homepage');
		// Ensure homepageText is a non-false value.
		for (var key in argv.source) {
			if (!homepageText) {
				try {
					files = glob.sync(argv.source[key] + '/**/styleguide.md');
					if (files.length) {
						homepageText = ' ' + marked(fs.readFileSync(files[0], 'utf8'));
					}
				} catch (e) {}
			}
		}
		if (!homepageText) {
			homepageText = ' ';
			console.log('   ...no homepage content found in styleguide.md.');
		}
	}
	else {
		filename = 'section-' + kss.KssSection.prototype.encodeReferenceURI(root) + '.html';
		console.log(
			' - section '+root+' [',
			styleguide.section(root) ? styleguide.section(root).header() : 'Unnamed',
			']'
		);
	}
	// Create the HTML to load the optional CSS and JS.
	for (var key in argv.css) {
		styles = styles + '<link rel="stylesheet" href="' + argv.css[key] + '">\n';
	}
	for (var key in argv.js) {
		scripts = scripts + '<script src="' + argv.js[key] + '"></script>\n';
	}
	fs.writeFileSync(argv.destination + '/' + filename,
		this.template({
			partials:     partials,
			styleguide:   styleguide,
			sectionRoots: sectionRoots,
			sections:     sections.map(function(section) { return section.JSON(); }),
			rootName:     root,
			argv:         argv || {},
			homepage:     homepageText,
			styles:       styles,
			scripts:      scripts
		})
	);
};
